// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: exams.queries.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countExamsBySubject = `-- name: CountExamsBySubject :one
SELECT COUNT(*) FROM exams
WHERE subject_id = $1
`

func (q *Queries) CountExamsBySubject(ctx context.Context, subjectID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countExamsBySubject, subjectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExamsByUser = `-- name: CountExamsByUser :one
SELECT COUNT(*) FROM exams
WHERE user_id = $1
`

func (q *Queries) CountExamsByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countExamsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExam = `-- name: CreateExam :one
INSERT INTO exams (user_id, title, subject_id, date)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, title, subject_id, date, created_at, updated_at
`

type CreateExamParams struct {
	UserID    string    `json:"user_id"`
	Title     string    `json:"title"`
	SubjectID uuid.UUID `json:"subject_id"`
	Date      time.Time `json:"date"`
}

func (q *Queries) CreateExam(ctx context.Context, arg CreateExamParams) (Exam, error) {
	row := q.db.QueryRowContext(ctx, createExam,
		arg.UserID,
		arg.Title,
		arg.SubjectID,
		arg.Date,
	)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.SubjectID,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExam = `-- name: DeleteExam :exec
DELETE FROM exams
WHERE id = $1
`

func (q *Queries) DeleteExam(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteExam, id)
	return err
}

const getExamByID = `-- name: GetExamByID :one
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name
FROM exams e
JOIN subjects s ON e.subject_id = s.id
WHERE e.id = $1
`

type GetExamByIDRow struct {
	ID          uuid.UUID    `json:"id"`
	UserID      string       `json:"user_id"`
	Title       string       `json:"title"`
	SubjectID   uuid.UUID    `json:"subject_id"`
	Date        time.Time    `json:"date"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetExamByID(ctx context.Context, id uuid.UUID) (GetExamByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getExamByID, id)
	var i GetExamByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.SubjectID,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SubjectName,
	)
	return i, err
}

const getExamWithStudyPlansCount = `-- name: GetExamWithStudyPlansCount :one
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name,
    COUNT(sp.id) as study_plans_count
FROM exams e
JOIN subjects s ON e.subject_id = s.id
LEFT JOIN study_plans sp ON e.id = sp.exam_id
WHERE e.id = $1
GROUP BY e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at, s.name
`

type GetExamWithStudyPlansCountRow struct {
	ID              uuid.UUID    `json:"id"`
	UserID          string       `json:"user_id"`
	Title           string       `json:"title"`
	SubjectID       uuid.UUID    `json:"subject_id"`
	Date            time.Time    `json:"date"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	SubjectName     string       `json:"subject_name"`
	StudyPlansCount int64        `json:"study_plans_count"`
}

func (q *Queries) GetExamWithStudyPlansCount(ctx context.Context, id uuid.UUID) (GetExamWithStudyPlansCountRow, error) {
	row := q.db.QueryRowContext(ctx, getExamWithStudyPlansCount, id)
	var i GetExamWithStudyPlansCountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.SubjectID,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SubjectName,
		&i.StudyPlansCount,
	)
	return i, err
}

const getExamsByDateRange = `-- name: GetExamsByDateRange :many
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name
FROM exams e
JOIN subjects s ON e.subject_id = s.id
WHERE e.user_id = $1
  AND e.date >= $2
  AND e.date <= $3
ORDER BY e.date ASC
`

type GetExamsByDateRangeParams struct {
	UserID string    `json:"user_id"`
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
}

type GetExamsByDateRangeRow struct {
	ID          uuid.UUID    `json:"id"`
	UserID      string       `json:"user_id"`
	Title       string       `json:"title"`
	SubjectID   uuid.UUID    `json:"subject_id"`
	Date        time.Time    `json:"date"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetExamsByDateRange(ctx context.Context, arg GetExamsByDateRangeParams) ([]GetExamsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getExamsByDateRange, arg.UserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamsByDateRangeRow
	for rows.Next() {
		var i GetExamsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.SubjectID,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamsBySubjectId = `-- name: GetExamsBySubjectId :many
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name
FROM exams e
JOIN subjects s ON e.subject_id = s.id
WHERE e.subject_id = $1
ORDER BY e.date ASC
`

type GetExamsBySubjectIdRow struct {
	ID          uuid.UUID    `json:"id"`
	UserID      string       `json:"user_id"`
	Title       string       `json:"title"`
	SubjectID   uuid.UUID    `json:"subject_id"`
	Date        time.Time    `json:"date"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetExamsBySubjectId(ctx context.Context, subjectID uuid.UUID) ([]GetExamsBySubjectIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getExamsBySubjectId, subjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamsBySubjectIdRow
	for rows.Next() {
		var i GetExamsBySubjectIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.SubjectID,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamsByUserAndSubject = `-- name: GetExamsByUserAndSubject :many
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name
FROM exams e
JOIN subjects s ON e.subject_id = s.id
WHERE e.user_id = $1 AND e.subject_id = $2
ORDER BY e.date ASC
`

type GetExamsByUserAndSubjectParams struct {
	UserID    string    `json:"user_id"`
	SubjectID uuid.UUID `json:"subject_id"`
}

type GetExamsByUserAndSubjectRow struct {
	ID          uuid.UUID    `json:"id"`
	UserID      string       `json:"user_id"`
	Title       string       `json:"title"`
	SubjectID   uuid.UUID    `json:"subject_id"`
	Date        time.Time    `json:"date"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetExamsByUserAndSubject(ctx context.Context, arg GetExamsByUserAndSubjectParams) ([]GetExamsByUserAndSubjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getExamsByUserAndSubject, arg.UserID, arg.SubjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamsByUserAndSubjectRow
	for rows.Next() {
		var i GetExamsByUserAndSubjectRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.SubjectID,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamsByUserId = `-- name: GetExamsByUserId :many
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name
FROM exams e
JOIN subjects s ON e.subject_id = s.id
WHERE e.user_id = $1
ORDER BY e.date ASC
`

type GetExamsByUserIdRow struct {
	ID          uuid.UUID    `json:"id"`
	UserID      string       `json:"user_id"`
	Title       string       `json:"title"`
	SubjectID   uuid.UUID    `json:"subject_id"`
	Date        time.Time    `json:"date"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetExamsByUserId(ctx context.Context, userID string) ([]GetExamsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getExamsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamsByUserIdRow
	for rows.Next() {
		var i GetExamsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.SubjectID,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamsWithStudyPlansCount = `-- name: GetExamsWithStudyPlansCount :many
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name,
    COUNT(sp.id) as study_plans_count
FROM exams e
JOIN subjects s ON e.subject_id = s.id
LEFT JOIN study_plans sp ON e.id = sp.exam_id
WHERE e.user_id = $1
GROUP BY e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at, s.name
ORDER BY e.date ASC
`

type GetExamsWithStudyPlansCountRow struct {
	ID              uuid.UUID    `json:"id"`
	UserID          string       `json:"user_id"`
	Title           string       `json:"title"`
	SubjectID       uuid.UUID    `json:"subject_id"`
	Date            time.Time    `json:"date"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	SubjectName     string       `json:"subject_name"`
	StudyPlansCount int64        `json:"study_plans_count"`
}

func (q *Queries) GetExamsWithStudyPlansCount(ctx context.Context, userID string) ([]GetExamsWithStudyPlansCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getExamsWithStudyPlansCount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamsWithStudyPlansCountRow
	for rows.Next() {
		var i GetExamsWithStudyPlansCountRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.SubjectID,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
			&i.StudyPlansCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextExamBySubject = `-- name: GetNextExamBySubject :one
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name
FROM exams e
JOIN subjects s ON e.subject_id = s.id
WHERE e.subject_id = $1 AND e.date >= CURRENT_DATE
ORDER BY e.date ASC
LIMIT 1
`

type GetNextExamBySubjectRow struct {
	ID          uuid.UUID    `json:"id"`
	UserID      string       `json:"user_id"`
	Title       string       `json:"title"`
	SubjectID   uuid.UUID    `json:"subject_id"`
	Date        time.Time    `json:"date"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetNextExamBySubject(ctx context.Context, subjectID uuid.UUID) (GetNextExamBySubjectRow, error) {
	row := q.db.QueryRowContext(ctx, getNextExamBySubject, subjectID)
	var i GetNextExamBySubjectRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.SubjectID,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SubjectName,
	)
	return i, err
}

const getPastExams = `-- name: GetPastExams :many
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name
FROM exams e
JOIN subjects s ON e.subject_id = s.id
WHERE e.user_id = $1 AND e.date < CURRENT_DATE
ORDER BY e.date DESC
`

type GetPastExamsRow struct {
	ID          uuid.UUID    `json:"id"`
	UserID      string       `json:"user_id"`
	Title       string       `json:"title"`
	SubjectID   uuid.UUID    `json:"subject_id"`
	Date        time.Time    `json:"date"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetPastExams(ctx context.Context, userID string) ([]GetPastExamsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPastExams, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPastExamsRow
	for rows.Next() {
		var i GetPastExamsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.SubjectID,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubjectStats = `-- name: GetSubjectStats :one
SELECT
    s.id,
    s.name,
    COUNT(DISTINCT e.id) as total_exams,
    COUNT(DISTINCT CASE WHEN e.date >= CURRENT_DATE THEN e.id END) as upcoming_exams,
    COUNT(DISTINCT CASE WHEN e.date < CURRENT_DATE THEN e.id END) as past_exams,
    COUNT(DISTINCT sp.id) as total_study_plans,
    MIN(CASE WHEN e.date >= CURRENT_DATE THEN e.date END) as next_exam_date
FROM subjects s
LEFT JOIN exams e ON s.id = e.subject_id
LEFT JOIN study_plans sp ON e.id = sp.exam_id
WHERE s.id = $1
GROUP BY s.id, s.name
`

type GetSubjectStatsRow struct {
	ID              uuid.UUID   `json:"id"`
	Name            string      `json:"name"`
	TotalExams      int64       `json:"total_exams"`
	UpcomingExams   int64       `json:"upcoming_exams"`
	PastExams       int64       `json:"past_exams"`
	TotalStudyPlans int64       `json:"total_study_plans"`
	NextExamDate    interface{} `json:"next_exam_date"`
}

func (q *Queries) GetSubjectStats(ctx context.Context, id uuid.UUID) (GetSubjectStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSubjectStats, id)
	var i GetSubjectStatsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TotalExams,
		&i.UpcomingExams,
		&i.PastExams,
		&i.TotalStudyPlans,
		&i.NextExamDate,
	)
	return i, err
}

const getUpcomingExams = `-- name: GetUpcomingExams :many
SELECT
    e.id, e.user_id, e.title, e.subject_id, e.date, e.created_at, e.updated_at,
    s.name as subject_name
FROM exams e
JOIN subjects s ON e.subject_id = s.id
WHERE e.user_id = $1 AND e.date >= CURRENT_DATE
ORDER BY e.date ASC
LIMIT $2
`

type GetUpcomingExamsParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
}

type GetUpcomingExamsRow struct {
	ID          uuid.UUID    `json:"id"`
	UserID      string       `json:"user_id"`
	Title       string       `json:"title"`
	SubjectID   uuid.UUID    `json:"subject_id"`
	Date        time.Time    `json:"date"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetUpcomingExams(ctx context.Context, arg GetUpcomingExamsParams) ([]GetUpcomingExamsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUpcomingExams, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUpcomingExamsRow
	for rows.Next() {
		var i GetUpcomingExamsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.SubjectID,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExam = `-- name: UpdateExam :one
UPDATE exams
SET title = $2,
    subject_id = $3,
    date = $4,
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, title, subject_id, date, created_at, updated_at
`

type UpdateExamParams struct {
	ID        uuid.UUID `json:"id"`
	Title     string    `json:"title"`
	SubjectID uuid.UUID `json:"subject_id"`
	Date      time.Time `json:"date"`
}

func (q *Queries) UpdateExam(ctx context.Context, arg UpdateExamParams) (Exam, error) {
	row := q.db.QueryRowContext(ctx, updateExam,
		arg.ID,
		arg.Title,
		arg.SubjectID,
		arg.Date,
	)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.SubjectID,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
